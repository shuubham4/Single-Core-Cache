/*
 * 
 * cache.c
 * 
 * Donald Yeung
 */


#include <stdio.h>
#include <math.h>

#include "cache.h"
#include "main.h"

/* cache configuration parameters */
static int cache_split = 0;
static int cache_usize = DEFAULT_CACHE_SIZE;
static int cache_isize = DEFAULT_CACHE_SIZE; 
static int cache_dsize = DEFAULT_CACHE_SIZE;
static int cache_block_size = DEFAULT_CACHE_BLOCK_SIZE;
static int words_per_block = DEFAULT_CACHE_BLOCK_SIZE / WORD_SIZE;
static int cache_assoc = DEFAULT_CACHE_ASSOC;
static int cache_writeback = DEFAULT_CACHE_WRITEBACK;
static int cache_writealloc = DEFAULT_CACHE_WRITEALLOC;

/* cache model data structures */
static Pcache icache;
static Pcache dcache;
static cache c1;
static cache c2;
static cache_stat cache_stat_inst;
static cache_stat cache_stat_data;

/************************************************************/
void set_cache_param(param, value)
  int param;
  int value;
{

  switch (param) {
  case CACHE_PARAM_BLOCK_SIZE:
    cache_block_size = value;
    words_per_block = value / WORD_SIZE;
    break;
  case CACHE_PARAM_USIZE:
    cache_split = FALSE;
    cache_usize = value;
    break;
  case CACHE_PARAM_ISIZE:
    cache_split = TRUE;
    cache_isize = value;
    break;
  case CACHE_PARAM_DSIZE:
    cache_split = TRUE;
    cache_dsize = value;
    break;
  case CACHE_PARAM_ASSOC:
    cache_assoc = value;
    break;
  case CACHE_PARAM_WRITEBACK:
    cache_writeback = TRUE;
    break;
  case CACHE_PARAM_WRITETHROUGH:
    cache_writeback = FALSE;
    break;
  case CACHE_PARAM_WRITEALLOC:
    cache_writealloc = TRUE;
    break;
  case CACHE_PARAM_NOWRITEALLOC:
    cache_writealloc = FALSE;
    break;
  default:
    printf("error set_cache_param: bad parameter value\n");
    exit(-1);
  }

}

void init_cache()
{ 
  // Building unified Cache
  if (cache_split = 0){
  	my_cache = (cache*)malloc(sizeof(cache)); // use double pointers here   
        my_cache->size = cache_usize;
        my_cache->associativity = cache_assoc;
        my_cache->nsets = cache_usize/(cache_block_size*cache_assoc);
        set_contents = (int*)malloc(sizeof(int)*my_cache.nsets);
        my_cache->LRU_head = (Pcache_line*)malloc(sizeof(Pcache_line)*my_cache.nsets); // may need to shift these to perform access 
        my_cache->LRU_tail = (Pcache_line*)malloc(sizeof(Pcache_line)*my_cache.nsets); // may need to shift these to perform access
        my_cache->index_mask_offset = LOG2(cache_block_size);  
        my_cache->index_mask = pow(2, LOG2(my_cache->nsets) + LOG2(cache_block_size));  // convert to hexadecimal mask somehow 
  }
  
  // Building split caches 
  /*if (cache_split = 1){
      my_cache = (cache*)malloc(sizeof(cache)); // use double pointers here
      my_cache->size = cache_usize;
      my_cache->associativity = cache_assoc;
      my_cache->nsets = cache_usize/(cache_block_size*cache_assoc);
      set_contents = (int*)malloc(sizeof(int)*my_cache.nsets);
      my_cache->LRU_head = (Pcache_line*)malloc(sizeof(Pcache_line)*my_cache.nsets);
      my_cache->LRU_tail = (Pcache_line*)malloc(sizeof(Pcache_line)*my_cache.nsets);
      //if (){  fully associative case
      //        //}
      //my_cache->index_mask = LOG2(my_cache->nsets);
      //my_cache->index_mask_offset = LOG2(cache_block_size);
      //}*/

  // create cache_data_stats struct and initialise: use double pointers 
}

void perform_access(addr, access_type)
  unsigned addr, access_type;
{
    // if (split cache or unified cache) // consider possibilities
    // find if data store or load 
    //    if data store: 
    //       if write back: 
    //         if no write allocate:  
    //            if tag matches: update:    
    //            if tag doesn't match: update:  
    //         if write allocate:
    //            if tag matches: update:
    //            if tag doesn't match: update: 
    //
    //       else if write through:
    //         if no write allocate:
    //            if tag matches: update: 
    //            else if tag doesnt match:  
    //         if write allocate:   
    //
    //    else if data load:
    //       if tag matches: update: access, 
    //       if tag doesnt match: update: access, misses, data_fetch, replacement. 
    //       
    //
    //    else (instruction load): (be instruction cache specific) 
    //       if tag matches: update: access
    //       if tag doesnt match: update: access, misses, replacement. 
    //

}

void flush()
{

 

}

void delete(head, tail, item)
  Pcache_line *head, *tail;
  Pcache_line item;
{
  if (item->LRU_prev) {
    item->LRU_prev->LRU_next = item->LRU_next;
  } else {
    /* item at head */
    *head = item->LRU_next;
  }

  if (item->LRU_next) {
    item->LRU_next->LRU_prev = item->LRU_prev;
  } else {
    /* item at tail */
    *tail = item->LRU_prev;
  }
}
/************************************************************/

/************************************************************/
/* inserts at the head of the list */
void insert(head, tail, item)
  Pcache_line *head, *tail;
  Pcache_line item;
{
  item->LRU_next = *head;
  item->LRU_prev = (Pcache_line)NULL;

  if (item->LRU_next)
    item->LRU_next->LRU_prev = item;
  else
    *tail = item;

  *head = item;
}
/************************************************************/

/************************************************************/
void dump_settings()
{
  printf("Cache Settings:\n");
  if (cache_split) {
    printf("\tSplit I- D-cache\n");
    printf("\tI-cache size: \t%d\n", cache_isize);
    printf("\tD-cache size: \t%d\n", cache_dsize);
  } else {
    printf("\tUnified I- D-cache\n");
    printf("\tSize: \t%d\n", cache_usize);
  }
  printf("\tAssociativity: \t%d\n", cache_assoc);
  printf("\tBlock size: \t%d\n", cache_block_size);
  printf("\tWrite policy: \t%s\n", 
	 cache_writeback ? "WRITE BACK" : "WRITE THROUGH");
  printf("\tAllocation policy: \t%s\n",
	 cache_writealloc ? "WRITE ALLOCATE" : "WRITE NO ALLOCATE");
}
/************************************************************/

/************************************************************/
void print_stats()
{
  printf("*** CACHE STATISTICS ***\n");
  printf("  INSTRUCTIONS\n");
  printf("  accesses:  %d\n", cache_stat_inst.accesses);
  printf("  misses:    %d\n", cache_stat_inst.misses);
  printf("  miss rate: %f\n", 
	 (float)cache_stat_inst.misses / (float)cache_stat_inst.accesses);
  printf("  replace:   %d\n", cache_stat_inst.replacements);

  printf("  DATA\n");
  printf("  accesses:  %d\n", cache_stat_data.accesses);
  printf("  misses:    %d\n", cache_stat_data.misses);
  printf("  miss rate: %f\n", 
	 (float)cache_stat_data.misses / (float)cache_stat_data.accesses);
  printf("  replace:   %d\n", cache_stat_data.replacements);

  printf("  TRAFFIC (in words)\n");
  printf("  demand fetch:  %d\n", cache_stat_inst.demand_fetches + 
	 cache_stat_data.demand_fetches);
  printf("  copies back:   %d\n", cache_stat_inst.copies_back +
	 cache_stat_data.copies_back);
}
/************************************************************/
